<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>EZCAD: EZCAD3: Easy (Mechanical) Computer Aided Design -- Version 3</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">EZCAD
   &#160;<span id="projectnumber">3</span>
   </div>
   <div id="projectbrief">Easy Computer Aided Design</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="namespaceEZCAD3.html" title="More details here...">EZCAD3</a>: Easy (Mechanical) Computer Aided Design -- Version 3 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>Introduction</h1>
<p>EZCAD stands for Easy Computed Aided Design. EZCAD is a mechanical CAD (Computer Aided Design) system with an integrated mechanical CAM (Computer Aided Manufacture) system. The CAD system specifies the geometry of individual parts and how they are assembled together. The CAM system specifies the manufacturing steps required to make each individual part.</p>
<p>In EZCAD, the designer writes a program using the <a href="http://www.python.org/">Python</a> programming language. The python program is then executed to generate both the design visualization and all associated manufacturing files (e.g. .stl files for 3-printers, G-codes for CNC mills/lathes, .dxf files for laser printers, etc.) EZCAD does not include either a text editor or a visualization tool. Instead, the designer uses their preferred text editor (e.g. idle, emacs, vim, etc.) and they use their own preferred visualization tools (e.g. meshlab, etc.) Other tools are used to visualize generated manufacturing files.</p>
<p>In short, EZCAD is just a Python library that is executed to generate the various design files.</p>
<h1>Downloading, Documentation, and Licensing</h1>
<h2>Downloading</h2>
<p>This package is distributed in source form from a <em>git</em> repository. To get a copy: </p>
<pre class="fragment">    git clone https://github.com/waynegramlich/ezcad3.git
</pre><p>In addition, this package needs a version of <a href="http://www.openscad.org/">OpenSCAD</a>. For those who use Linux distributions based on the Debian package system (e.g. Ubuntu, Mint, etc.), the following will do the trick: </p>
<pre class="fragment">    sudo apt-get install openscad
</pre><p>OpenSCAD is primarily used as a front-end to the wonderful <a href="http://www.cgal.org/">CGAL</a>(Computational Geometry Algorithms Library). In particular, OpenSCAD uses the Boolean 3D solids library embodied in the NEF3 sub-library of CGAL.</p>
<p>Detailed documentation of the Python classes and associated methods is maintained by <a href="http://www.doxygen.org/">Doxygen</a>. For convenience, all of the generated Doxygen documentation is checked into the repository. If you want to generate Doxygen documentation locally, you need to download Doxygen I downloaded my copy via: </p>
<pre class="fragment">    sudo apt-get install doxygen
</pre><h2>Documentation</h2>
<p>At the moment, the only documentation is this document and the <a href="html/pages.html">Doxygen generated documentation</a>.</p>
<h2>Licensing</h2>
<p>In general, I really like Open Source Licenses. I have a slight preference of the GPL open source license, so that is what <a class="el" href="namespaceEZCAD3.html" title="More details here...">EZCAD3</a> is released under. I emulate the <a href="http://www.fsf.org">Free Software Foundation</a> in that any code contributed to my code branch requires a copyright assignment. Professor Eben Moglen has written up a short explanation of <a href="http://www.gnu.org/licenses/why-assign.html">Why the FSF gets copyright assignments from contributors</a>. I strongly feel that having a unified copyright owner provides maximum protection for the open source software. While it is possible to get <a href="http://ftp.xemacs.org/old-beta/FSF/assign.changes">overly legalistic</a>, I think the following is more that adequate to assign the copyright: </p>
<pre class="fragment">    Hello:

    I am assigning my modifications to EZCAD to
    Wayne C. Gramlich with the requirement that the code
    will continue to be released under the GPL version 3
    license or higher.

    Regards,

    {Your name here}
</pre><p>Enough on this legal stuff!</p>
<h1>EZCAD Overview</h1>
<p>In EZCAD, the most important Python class is the <em>Part</em> class. The <em>Part</em> class is used to both manufacture individual parts <em>and</em> to assemble the individual parts together into sub-assemblies.</p>
<p>In addition to the <em>Part</em> class there are bunch of utility classes. In alphabetical order, the utility classes are:</p>
<ul>
<li><em>Angle</em> is used to represent angles.</li>
</ul>
<ul>
<li><em>Color</em> is used to represent a represent the color that an individual part is rendered as.</li>
</ul>
<ul>
<li><em>L</em> is used to represent a length (e.g. mm, cm, inch, ft, etc.) (This type is shortened to "L" because is used so much.)</li>
</ul>
<ul>
<li><em>Material</em> specifies what material a part is manufactured out of.</li>
</ul>
<ul>
<li><em>P</em> is used to represent a point in a 3-dimensional Cartesian coordinate system. (This type is shortened to "P" because is used so much.)</li>
</ul>
<p>Each EZCAD class method validates that its arguments types are correct. (If you have ever heard of the "duck typing" design pattern, EZCAD most definitely does <b>not</b> use that particular design pattern.)</p>
<p>The CAM (Computer Aided Manufacture) portion of EZCAD is based on the following classes:</p>
<ul>
<li><em>EZCAD</em> is the global object that orchestrates the entire process.</li>
</ul>
<ul>
<li><em>Shop</em> is the parent class that specifies all the available machines and associated machine tooling.</li>
</ul>
<ul>
<li><em>Machine</em> is a specific machine such as a 3D-printer, laser-cutter, mill, lathe, drill press, etc.</li>
</ul>
<ul>
<li><em>Tool</em> is a specific tool that can be loaded into a machine. These include drill bits, end-mills, etc.</li>
</ul>
<p>The shop is specified independently from the part and sub-assembly file. The same part will generate different manufacturing files depending upon what machines and tooling is available in a given shop. Thus, different G-codes, .dxf files are generated depending upon what is available in the shop.</p>
<p>EZCAD operates in three distinct phases:</p>
<ul>
<li>Part Initialization. This phase creates a hierarchical name space of parts and sub-assemblies.</li>
</ul>
<ul>
<li>Constraint Propagation. This phase propagates dimensional changes around the overall design. This process also keeps track of the bounding box for each individual part and sub-assembly.</li>
</ul>
<ul>
<li>Manufacture and Assembly. This phase generates the required manufacturing files needed for construct the various parts. This phase also specifies where <em>Part</em>'s are placed in each sub-assembly.</li>
</ul>
<p>Each phase is quickly discussed below:</p>
<h2>Part Initialization Phase</h2>
<p>Each user individual part is implemented as a Python class object that sub-classes the <em>Part</em> super class. As expected, the initialization phase occurs in the *__init__*() method. Each part has an up-level parent (abbreviated as "*up*"). The following code fragment shows how it is done: </p>
<pre class="fragment">    class My_Part(Part):

        def __init__(self, up):
            Part.__init__(self, up)      # Initialize *Part* super-class
            self.part1_ = Part1(self)    # Initialize *Part1*
            # ...
            self.partN_ = PartN(self)    # Initialize *PartN*
</pre><p>The first line initializes the <em>Part</em> super class with <em>up</em> as the up-level parent. The second and subsequent lines initialize the various sub-parts. By convention, each sub-*Part* is stored into <em>self</em> with a trailing "_" suffix. (There is more about suffixes shortly below.)</p>
<p>After initialization is complete, each <em>Part</em> can access any other <em>Part</em> in the design using standard Python dot (".") notation. For example, <em>self.up.base_</em> will access the <em>base_</em> <em>Part</em> of the parent to <em>self</em>.</p>
<p>Due to the nature of Python, the designer will be storing dimensional values into their <em>Part</em>'s as member variables. EZCAD uses member variable suffixes to prevent accidental name clashes. Designers are <em>required</em> to use the standard suffixes listed below for their additional <em>Part</em> member variables:</p>
<ul>
<li>"_": <em>Part</em></li>
<li>"_a": <em>Angle</em></li>
<li>"_c": <em>Color*p</em></li>
<li><em>"_i": *int</em> (i.e. an integer number)</li>
<li>"_f": <em>float</em> (i.e. a floating point number)</li>
<li>"_l": <em>L</em> (i.e. a length)</li>
<li>"_m": <em>Material</em></li>
<li>"_o": Some other type</li>
<li>"_s": <em>str</em> (i.e. string)</li>
<li>"_p": <em>P</em> (i.e. a point)</li>
<li>"_pl": <em>Place</em></li>
</ul>
<p>All designer defined member variables <em>must</em> end with one of the suffixes above.</p>
<h2>Constraint Propagation Phase</h2>
<p>Constraint propagation is what allows the designer to relatively easily resize a design. The constraint propagation phase occurs in a <em>Part</em>'s <em>construct</em>() method. Constraint propagation occurs by repeatably calling the <em>construct</em>() method for each <em>Part</em> in the entire design. The <em>construct</em>() methods are repeatably called until none of the values with approved suffixes (e.g. "_l", "_p") change any more.</p>
<p>To further support constraint propagation, each <em>Part</em> maintains a bounding box for everything it contains. The bounding box uses an altitude/compass bearing naming convention. Using this convention, the X axis is uses East/Center/West names, the Y axis uses North/Center/South names, and the Z axis uses Top/Center/Bottom names. The following crude ASCII art should help to convey the concept. </p>
<pre class="fragment">                T  N (Y axis)
                | /
                |/
          W-----*-----E (X axis)
               /|
              / |
             S  B
               (Z-axis)
</pre><p>The bounding box of a part defines box that consists of 3 by 3 by 3 points. There are three slices &ndash; the top slice, the center slice, and bottom slice that are named as follows: </p>
<pre class="fragment">      tnw--tn---tne     nw----n----ne     bnw--bn---bne
      |     |     |     |     |     |     |     |     |
      tw----t----tw     w-----c-----e     bw----b----bw
      |     |     |     |     |     |     |     |     |
      tsw--ts---tse     sw----s----se     bsw--bs---bse
       (Top Slice)      (Center Slice)    (Bottom Slice)
</pre><p>The designer can easily access the various bounding box values using short concise member variable names. Thus, the <em>tne</em> member variable corresponds to the Top-North-West corner of the bounding box, <em>c</em> corresponds to the Center of the bounding box, and <em>bw</em> corresponds to the Bottom-West edge of the bounding box.</p>
<p>Using constraint propagation and bounding boxes, EZCAD encourages the use of an "assembly focused" design pattern where each <em>Part</em> is designed to fit precisely into the final assembly from the beginning. This is in contrast to the "part focused" design pattern where each part is individually designed and then subsequently fitted into the final assembly.</p>
<h2>Manufacture and Assembly Phase</h2>
<p>The manufacturing and assembly phase occurs last. EZCAD can generate manufacturing files for the following generic classes of machines:</p>
<ul>
<li>3D Printers (.stl file)</li>
</ul>
<ul>
<li>Laser Cutters (.dxf file)</li>
</ul>
<ul>
<li>CNC Mills and Lathes (.ngc file)</li>
</ul>
<p>EZCAD uses encourages a "design for manufacture" design pattern. For each part, the designer specifies one or more appropriate machines that could be used to manufacture the part. While some parts can only be manufactured on a single machine class, others can be manufactured on more than one machine class. For example, a plastic plate that has some holes, inner cut outs, and a specific exterior contour can actually be manufactured on a CNC mill, laser cutter, or 3D printer. The decision of which machine to use is deferred until the actual part needs to be manufactured.</p>
<p>EZCAD uses a two step process for designing a part:</p>
<ul>
<li>First, a bunch of material chunks (e.g. blocks, cylinders, extrusions, etc.) are "welded" together to provide a rough 3D chunk of material.</li>
</ul>
<ul>
<li>Second, a bunch of material removal operations (e.g. holes, pockets, exterior contour removal, etc.)</li>
</ul>
<p>The details of these operations are described much further below.</p>
<p>After each part is designed, there is a final step of placing each part into the final assembly. A single part or sub-assembly can easily be replicated multiple times in the final assembly.</p>
<p>Once the final assembly is present, it can be viewed using the appropriate visualization tool. Currently, both VRML (i.e. .wrl files) and OpenSCAD (i.e. .scad files) are supported for visualization.</p>
<h2>A Quick Example</h2>
<p>The example below creates a plastic box with a cover, where the cover has a lip that keeps the cover centered over the box. We present the entire code body first then will describe what is happening on a chunk by chunk basis next: </p>
<pre class="fragment">    #!/usr/bin/env python

    from EZCAD3 import *   # The EZCAD (revision 3) classes:

    class Simple_Box(Part):

        def __init__(self, up, dx=L(mm=100.0), dy=L(mm=50.0),
          dz=L(25.0), wall_thickness=L(mm=5.0),
          material=Material("plastic", "ABS")):
            # Initialize the *Part*:
            Part.__init__(self, up)

            # Remember the initialization values:
            self.dx_l = dx
            self.dy_l = dy
            self.dz_l = dz
            self.wall_thickness_l = wall_thickness
            self.material_m = material

            # Instantiate the sub-*Part*'s:
            self.base_ = Simple_Box_Base(self)
            self.cover_ = Simple_Box_Cover(self)

        def construct(self):
            pass

    class Simple_Box_Base(Part):

        def __init__(self, up):
            Part.__init__(self, up)

        def construct(self):
            # Grab some values from *box*:
            box = self.up
            dx = box.dx_l
            dy = box.dy_l
            dz = box.dz_l
            wall_thickness = box.wall_thickness_l
            material = box.material_m

            # Add another member_variable:
            self.height_l = height = dz - wall_thickness
            zero = L()

            # Start with a solid block of the right dimensions:
            height = dz - wall_thickness
            self.block(comment = "Initial block of material",
              material = material,
              color = Color("blue"),
              corner1 = P(-dx/2, -dy/2, zero),
              corner2 = P( dx/2,  dy/2, height))

            # Pocket out the body of the box:
            self.simple_pocket(comment = "Box Pocket",
              corner1 = self.bsw + \
                P(wall_thickness, wall_thickness, wall_thickness),
              corner2 = self.tne - \
                P(wall_thickness, wall_thickness, zero),
              pocket_top = "t")

    class Simple_Box_Cover(Part):

        def __init__(self, up, place = True):
            Part.__init__(self, up, place)

        def construct(self):
            # Grab some values from *parent* and *base*:
            box = self.up
            dx = box.dx_l
            dy = box.dy_l
            dz = box.dz_l
            material = box.material_m
            wall_thickness = box.wall_thickness_l
            base = box.base_
            base_height = base.height_l
            zero = L()

            # Compute local values:
            self.lip_thickness_l = lip_thickness = wall_thickness / 2
            self.gap_l = gap = L(mm = 0.1)

            # Do the top part of the cover:
            self.block(comment = "Cover Top",
              material = material,
              color = Color("green"),
              corner1 = base.tsw,
              corner2 = base.tne + P(z = wall_thickness))

            # Do the lip part of the cover:
            self.block(comment = "Cover Lip",
              corner1 = base.tsw + \
              P(wall_thickness + gap, wall_thickness + gap, -lip_thickness),
              corner2 = base.tne - \
              P(wall_thickness + gap, wall_thickness + gap, zero),
              welds = "t")

    if __name__== "__main__":
        ezcad = EZCAD3(0)               # Using EZCAD 3.0
        simple_box = Simple_Box(None)   # Initialize top-level sub-assembly
        simple_box.process(ezcad)       # Process the design
</pre><p>The code is explained in smaller steps below:</p>
<ul>
<li>On Unix-like operating systems (e.g. Linux, MacOS, etc.), the following command makes it possible to directly execute the python program from the command line: <pre class="fragment">  #!/usr/bin/env python
</pre></li>
</ul>
<ul>
<li>This pulls all of the classes for <a class="el" href="namespaceEZCAD3.html" title="More details here...">EZCAD3</a> into the program name space. <pre class="fragment">  from EZCAD3 import *   # The EZCAD (revision 3) classes:
</pre></li>
</ul>
<ul>
<li>This defines the top-level assemble for the box and names it <em>Simple_Box</em>. It is a sub-class of the <em>Part</em> class: <pre class="fragment">  class Simple_Box(Part):
</pre></li>
</ul>
<ul>
<li>This defines the initialization routine for the <em>Simple_Box</em> class. For EZCAD, the first argument of the initialize method is <em>self</em> and the second argument is always <em>up</em>. <em>up</em> is up-level <em>Part</em> part class that is the "parent" of the <em>Simple_Box</em>. In this particular code example, <em>None</em> is passed in to indicate that there is no "parent" class. The next five arguments are optional arguments named <em>dx</em>, <em>dy</em>, <em>dz</em>, <em>wall_thickness</em>, and <em>Material</em>. These arguments have default values if they are not specified. The default box dimensions are 100mm long (X direction), 50mm wide (Y direction), 25mm high (Z direction) with a wall thickness of 5mm. The default construction material is ABS plastic (similar to Lego brick plastic.): <pre class="fragment">      def __init__(self, up, dx=L(mm=100.0), dy=L(mm=50.0),
        dz=L(25.0), wall_thickness=L(mm=5.0),
        material=Material("plastic", "ABS")):
</pre></li>
</ul>
<ul>
<li>This initializes the <em>Part</em> super class with <em>self</em> and <em>up</em>: <pre class="fragment">          # Initialize the *Part*:
          Part.__init__(self, up)
</pre></li>
</ul>
<ul>
<li>This loads some values into member variables of the <em>Simple_Box</em> class. The member variables are <em>dx_l</em>, <em>dy_l</em>, <em>dz_l</em>, <em>wall_thickness_l</em>, and <em>material_m</em>. The first for member variables end with an *_l* suffix to indicate that they are <em>L</em> (i.e. length) objects. The <em>material_m" variable end with *_m</em> to indicate that it contains a <em>Material</em> object: <pre class="fragment">          # Remember the initialization values:
          self.dx_l = dx
          self.dy_l = dy
          self.dz_l = dz
          self.wall_thickness_l = wall_thickness
          self.material_m = material
</pre></li>
</ul>
<ul>
<li>These last lines of the *__init__*() method instantiate the <em>Simple_Box_Base</em> and <em>Simple_Box_Cover</em> <em>Part</em>'s. These two instances are stored into the <em>base_</em> and <em>cover_</em> member variables. These two variables end with a suffix of *_* to indicate that they are <em>Part</em> objects. The *_* suffix is <b>mandatory</b>, since the EZCAD system uses the *_* suffix to find the child <em>Part</em>'s of the <em>Simple_Box</em> assembly. <em>self</em> is passed into the *__init__* methods for both the <em>Simple_Box_Base</em> and <em>Simple_Box_Cover</em> classes because <em>self</em> is the "parent" for both: <pre class="fragment">          # Instantiate the sub-*Part*'s:
          self.base_ = Simple_Box_Base(self)
          self.cover_ = Simple_Box_Cover(self)
</pre></li>
</ul>
<ul>
<li>Every <em>Part</em> class must have a <em>construct</em>() method. In this particular case, where <em>Simple_Box</em> is a simple assembly. A simply assembly consists of an assembly where each of its sub <em>Part</em>'s is automatically placed into the assembly. Since a simple assembly is the "default" mode, no further operations are needed for the <em>construct</em>() method for <em>Simple_Box</em>. Thus, the Python <em>pass</em> statement is used to indicate that no further operations are needed: <pre class="fragment">      def construct(self):
          pass
</pre></li>
</ul>
<ul>
<li>This class defines the <em>Simple_Box_Base</em> <em>Part</em>. This class describes the shape of the box base. It is a sub-class of a <em>Part</em> class: <pre class="fragment">  class Simple_Box_Base(Part):
</pre></li>
</ul>
<ul>
<li>As is frequently the case with many <em>Part</em>'s to be manufactured the *__init__*() method simple calls the <em>Part</em> super class *__init__* initialization method: <pre class="fragment">      def __init__(self, up):
          Part.__init__(self, up)
</pre></li>
</ul>
<ul>
<li>The construct method for a <em>Part</em> to be manufactured is typically quite a bit more involved than a <em>Part</em> used as an assembly: <pre class="fragment">      def construct(self):
</pre></li>
</ul>
<ul>
<li>Usually we start with some statements that select various values defined in this part and others. In this case, we grab the dimension and material objects needed for construction the box base. Most of these dimensions are declared in the "parent" which is accessed using <em>self</em>.*up*. <pre class="fragment">          # Grab some values from *box*:
          box = self.up
</pre></li>
</ul>
<ul>
<li>Now using <em>box</em> we can select the five member variables from the <em>Simple_Box</em> "parent" assembly <em>Part</em>. The *_l* and *_m* suffixes are not needed for the local variables <em>dx</em>, <em>dy</em>, <em>dz</em>, <em>wall_thickness</em> and <em>material</em>: <pre class="fragment">          dx = box.dx_l
          dy = box.dy_l
          dz = box.dz_l
          wall_thickness = box.wall_thickness_l
          material = box.material_m
</pre></li>
</ul>
<ul>
<li>We compute a new member variable <em>height_l</em> for the <em>Box_Base</em> <em>Part</em> using the extracted dimensions from <em>box</em>. This variable is assigned to a local variable <em>height</em> and a <em>Simple_Box_Cover</em> member variable <em>height_l</em>. As usual, the member variable ends with an *_l* suffix to indicate that it is a length. In addition, a length of <em>zero</em> is created by invoking the <em>L</em> initialize method with no arguments: <pre class="fragment">          # Add another member variable:
          self.height_l = height = dz - wall_thickness
          zero = L()
</pre></li>
</ul>
<ul>
<li>Conceptually, we start the box with a block of material that is <em>dx</em> by <em>dy</em> by <em>height</em> in size. We start by providing a <em>comment</em> argument that shows up in the generated .scad and G code files. The material is the one we selected from <em>box</em>. The color is specified by providing a <em>Color</em> object. This <em>Color</em> object is blue. Finally, two diametrically opposite corners are specified with the <em>corner1</em> and <em>corner2</em> arguments. In this particular case, the designer has decided that the bottom of the box is centered on the origin and extends upward by <em>height</em>. The <em>P</em> (i.e. point) class is used to specify the X/Y/Z coordinates of each corner: <pre class="fragment">          # Start with a solid block of the right dimensions:
          self.block(comment = "Initial block of material",
            material = material,
            color = Color("blue"),
            corner1 = P(-dx/2, -dy/2, zero),
            corner2 = P( dx/2,  dy/2, height))
</pre></li>
</ul>
<ul>
<li>The empty contents of the box base is removed from the original block via a <em>simple_pocket</em>() method. The <em>simple_pocket</em> method starts with a <em>comment</em> argument. Like the <em>block</em> method, the two diametrically opposite corners are used to specify the pocket dimensions. In this code the bounding box dimensions for <em>Simple_Box_Base</em> are used. The <em>corner1</em> argument is specified starting from the <em>bsw</em> (Bottom, South, West) corner and has <em>P</em>(<em>wall_thickness</em>, <em>wall_thickness</em>, <em>wall_thickness</em>) added to it. The <em>corner2</em> argument is specified starting from the <em>tne</em> (Top, North, East) corner and has <em>P</em>(<em>wall_thickness</em>, <em>wall_thickness</em>, <em>zero</em>)) subtracted from it. Lastly, it is useful to inform the system where the top of the pocket is. This is done by setting <em>pocket_top</em> to "t" (for Top). This causes the pocket to extend upwards just a little to make sure that the 3D solids package does not accidentally leave a thin slice of material behind on top: <pre class="fragment">          # Pocket out the body of the box:
          self.simple_pocket(comment = "Box Pocket",
            corner1 = self.bsw + \
              P(wall_thickness, wall_thickness, wall_thickness),
            corner2 = self.tne - \
              P(wall_thickness, wall_thickness, zero),
            pocket_top = "t")
</pre></li>
</ul>
<ul>
<li>The <em>Box_Cover</em> class is very similar to the <em>Box_Base</em> class. Thus, only the important differences are discussed below.</li>
</ul>
<ul>
<li>There are no surprises with the *__init__* method: <pre class="fragment">  class Simple_Box_Cover(Part):
      def __init__(self, up, place):
          Part.__init__(self, up)
</pre></li>
</ul>
<ul>
<li>The first part of the <em>construct</em>() method is pretty similar. The <em>box</em> and <em>base</em> parts are selected using standard Python dot ('.') notation. The <em>base_height</em> variable is obtained from <em>base</em> using the <em>Simple_Box_Base</em> <em>height_l</em> member variable. <pre class="fragment">      def construct(self):
          # Grab some values from *parent* and *base*:
          box = self.up
          dx = box.dx_l
          dy = box.dy_l
          dz = box.dz_l
          material = box.material_m
          wall_thickness = box.wall_thickness_l
          base = box.base_
          base_height = base.height_l
          zero = L()
</pre></li>
</ul>
<ul>
<li>Two new variables, <em>lip_thickness</em> and <em>gap</em>, are defined. In addition, two new member variables defined &ndash; <em>lip_thickness_l</em> and <em>gap_l</em>. As usual these have the required *_l* suffixes: <pre class="fragment">          # Compute local values:
          self.lip_thickness_l = lip_thickness = wall_thickness/2
          self.gap_l = gap = L(mm = 0.1)
</pre></li>
</ul>
<ul>
<li>Like <em>Simple_Box_Base</em>, the <em>Simple_Box_Cover</em> design starts with a block ABS plastic that is colored green to differentiate it from the blue base.. This top is carefully, aligned to fit on top of the <em>Simple_Box_Base</em> <em>Part</em>. <em>corner1</em> is set to the Top/South/West corner of <em>base</em>. <em>corner1</em> is set to the Top/North/East corner of base plus the height of the cover (i.e. <em>wall_thickness</em>.) Notice that the point only specifies <em>z</em> dimension and the <em>x</em> and <em>y</em> dimensions default to a length of 0: <pre class="fragment">          # Do the top part of the cover:
          self.block(comment = "Cover Top",
            material = material,
            color = Color("green"),
            corner1 = base.tsw,
            corner2 = base.tne + P(z = wall_thickness))
</pre></li>
</ul>
<ul>
<li>The cover lip is a block of ABS plastic that is welded to the bottom of the previous block. There can only be one material and color for a <em>Part</em> so there is no need to specify either <em>material</em> or <em>color</em> to this second <em>block</em>() method call. The <em>comment</em> is specified as "Cover Lip". <em>corner1</em> is equal to <em>base</em> Top/South/West plus the (<em>wall_thickness</em> + <em>gap</em>) in X and Y, and -*lip_thickness* in Z. <em>corner2</em> is equal to <em>base</em> Top/North/East minus (<em>wall_thickness</em> + <em>gap</em>) in X and Y, and 0 in Z. For EZCAD, each block, cylinder, extrusion, etc. that is specified is "welded" together into a single chunk of material. The 3D solids packages sometimes leave an infinitesimally thin gap between two material chunks. By setting <em>welds</em> to "t" (i.e. Top), the block is extended a small amount up into the adjoining part to force the two parts to be welded together: <pre class="fragment">          # Do the lip part of the cover:
          self.block(comment = "Cover Lip",
            corner1 = base.tsw + \
            P(wall_thickness + gap, wall_thickness + gap, -lip_thickness),
            corner2 = base.tne - \
            P(wall_thickness + gap, wall_thickness + gap, zero),
            welds = "t")
</pre></li>
</ul>
<ul>
<li>At the bottom of the file is the code to execute the design is enclosed in the standard Python design pattern of testing *__name__* for equality with "*__main__*". If they are equal, the program is the top level program and the EZCAD processing code is executed. Otherwise, it is not a top level program, and the code is actually being imported into another Python module. In this case, the EZCAD processing code is not executed here, but higher up in the top level program. This design pattern allows parts to be nested. Thus, one person can put a <em>Part</em> design in one file, other person can put yet another design in a second file, and yet a third person can glue them together using Python "import" commands in yet at third file: <pre class="fragment">  if __name__== "__main__":
</pre></li>
</ul>
<ul>
<li>For the final processing sequence, an <em><a class="el" href="namespaceEZCAD3.html" title="More details here...">EZCAD3</a></em> object is allocated and initialized. The major revision number is 3 and the minor revision number is 0. Next, the top-level <em>Simple_Box</em> assembly is allocated and initialized. Finally, the <em>process</em>() method is invoked on <em>simple</em> to cause the design to be processed.: <pre class="fragment">      ezcad = EZCAD3(0)               # Using EZCAD 3.0
      simple_box = Simple_Box(None)   # Initialize top-level sub-assembly
      simple_box.process(ezcad)       # Process the design
</pre></li>
</ul>
<ul>
<li>For those of you who like to scrunch everything onto one line, this could be replaced by: <pre class="fragment">      Simple_Box(None).process(EZCAD3(0))
</pre></li>
</ul>
<p>Hopefully, the example above gives you the an idea of how EZCAD works. When this program is executed it produces the following files:</p>
<ul>
<li>Simple_Box_Base.stl: An .stl file to manufacture the base with.</li>
<li>Simple_Box_Cover.stl: An .stl file to manufacture the cover with.</li>
<li>Simple_Box.scad: An .scad file to view the box assembly.</li>
<li>Simple_Box_Base.scad: An .scad file to view the box base part.</li>
<li>Simple_Box_Cover.scad. An .scad file to view the box cover part.</li>
<li>Simple_Box.wrl: An VRML file to view the box assembly.</li>
<li>Simple_Box_Base.wrl: An VRML file to view the box base part.</li>
<li>Simple_Box_Cover.wrl. An VRML file to view the box cover part.</li>
</ul>
<p>The .scad files can be view with OpenSCAD and the .wrl files can be view with a VRML viewer (e.g. meshlab.)</p>
<h1>CAD Class Reference</h1>
<p>This section covers the design classes. The lower level classes are covered first, followed by the <em>Part</em> class. The next major section after this covers the manufacturing classes (e.g. <em>Shop</em>, <em>Machine</em>, <em>Tool</em>, etc.)</p>
<h2>The <em>Angle</em> Class</h2>
<p>The <em>Angle</em> class represents an angle. While most designers specify their angles in degrees, internally the <em>Angle</em> class represents angles in radians.</p>
<p>The initializer can specify angles in either degrees or radians: </p>
<pre class="fragment">    degrees0 = Angle()                    # No arguments is 0 degrees
    degrees90 = Angle(deg = 90.0)         # Angle specified in degrees
    degrees180 = Angle(rad = 3.14.15926)  # Angle specified in radians
</pre><p>An <em>Angle</em> can be convert back into a <em>float</em> using a conversion method: </p>
<pre class="fragment">    d = degrees90.deg()                   # Convert to degrees
    r = degress180.rad()                  # Convert to radians
</pre><p><em>Angle</em>'s can be added, subtracted, multiplied, divided, etc.: </p>
<pre class="fragment">    a = degrees90 + degrees180            # Addition
    b = degrees90 - degrees180            # Subtraction
    c = degrees90 * 3                     # Multiplication
    d = degrees90 / 3                     # Division
    e = -degrees90                        # Negation
</pre><p>Comparison of <em>Angle</em> objects is supported: </p>
<pre class="fragment">    eq = degrees90 == degrees90     # Equality
    ge = degrees180 &gt;= degrees90    # Greater than or equal
    gt = degrees180 &gt; degrees90     # Greater than
    le = degress0 &lt;= degress180     # Less than or equal
    lt = degress0 &lt; degress180      # Less than
    ne = degrees0 != degress180     # Inequality
</pre><p>An <em>Angle</em> object can be formatted using the standard Python format facility. The units can be specified by suffix character: </p>
<pre class="fragment">    angle = Angle(deg = 180.0)
    print("degrees={0:d} radians={0:r}".format(angle))
</pre><p>will print: </p>
<pre class="fragment">    degrees=180.0 radians=3.14159265359
</pre><p>There are three trigimetric functions for angles: </p>
<pre class="fragment">    angle.sine()                    # sin(angle)
    angle.cosine()                  # cos(angle)
    angle.tangent()                 # tan(angle)
</pre><p>There is a miscellaneous <em>Angle</em> class: </p>
<pre class="fragment">    angle.normalize()               # Angle between -180 and  180 degrees
</pre><p>Read the <a href="html/classEZCAD3_1_1Angle.html">Doxygen generated *Angle* class information</a> to get the detailed method documenation.</p>
<h2>The <em>Color</em> Class</h2>
<p><em>Color</em> class documentation goes here.</p>
<h2>The <em>L</em> (i.e. Length) Class</h2>
<p>The <em>L</em> class represents a length. While the length can be specified in units of centimeters, millimeters, inches, and feet, internally, the <em>L</em> class converts everything to millimeters. Here are some examples of creating a length: </p>
<pre class="fragment">    length0 = L()                   # Length of 0.0
    length2mm = L(mm = 2)           # 2.0 millimeters (note *int* is OK)
    length3_5cm = L(cm = 3.5)       # 3.5 centimeters
    length1thou = L(inch = .001)    # One thousandth of an inch
    length6feet = L(ft = 3)         # 3 feet (which happens to be 1 yard)
    length1_3_4 = L(inch = "1-3/4") # 1.75 inches
</pre><p>An <em>L</em> object can be converted back into <em>float</em> using a conversion method: </p>
<pre class="fragment">    length.mm()                     # Millimeters
    length.cm()                     # Centimeters
    length.inch()                   # Inches
    length.ft()                     # Feet.
</pre><p>As expected, <em>L</em> objects can be added, subtracted, multiplied, divided, etc.: </p>
<pre class="fragment">    a = length2mm + length1though   # Addition
    b = length6feet - length3_5cm   # Subtraction
    c = length6feet * 2             # Mulitplication by *int* (or *float*)
    d = length2mm / 2.3             # Division by a *float* (or *int*)
    e = -length3_5cm                # Negation
</pre><p>Comparisons between <em>L</em> object are permitted: </p>
<pre class="fragment">    eq = length2mm == length2mm     # Equality
    ge = length2mm &gt;= length0       # Greater than or equal
    gt = length2mm &gt; length1thou    # Greater than
    le = length0 &lt;= length2mm &lt;=    # Less than or equal
    lt = length1thou &lt; length2mm &lt;  # Less than
    ne = length3_5cm != length6feet # Inequality
</pre><p><em>L</em> object can be formatted using the Python formatting system. For example: </p>
<pre class="fragment">    length = L(inch = 1)
    print("mm={0:m} cm={0:c} inch={0:i} ft={0:f}".format(length))
</pre><p>will print out: </p>
<pre class="fragment">    mm=25.4 cm=2.54 inch=1.0 ft=0.08333333333
</pre><p>If no suffix is provided, millimetes will be used the for output units. In general, it is best to always specify the units.</p>
<p>In addition, it is possible to use standard float syntax to futher control the formatting. Thus: </p>
<pre class="fragment">    print("ft={0:.4f}".format(length)
</pre><p>will print out: </p>
<pre class="fragment">    ft=0.8333
</pre><p>There are trigametric methods for <em>L</em> objects that multiply the a length by a trigimetric function: </p>
<pre class="fragment">    length.sine(angle)        # == length * angle.sine()
    length.cosine(angle)      # == length * angle.cosine()
    length.tangent(angle)     # == length * angle.tangent()
</pre><p>In addtion there is: </p>
<pre class="fragment">    dy.arctangent2(dx)        # == Angle(rad=math.atan2(dy.mm(), dz.mm()))
</pre><p>There are a few miscellaneous <em>L</em> methods as well: </p>
<pre class="fragment">    length1.absolute()        # Absolute value of (length1)
    length1.maximim(length2)  # Maximum of length1 and length2
    length2.minimum(length2)  # Minimum of length1 and length2
</pre><p>The detailed method documentation generated by Doxygen is <a href="html/classEZCAD3_1_1L.html">available</a>.</p>
<h2>The <em>Material</em> Class</h2>
<p><em>Matierial</em> class documentation goes here.</p>
<h2>The <em>P</em> (i.e. point) class</h2>
<p><em>P</em> class documenation goes here.</p>
<h2>The <em>Part</em> Class</h2>
<p><em>Part</em> Class documenation goes here:</p>
<p>Bounding Box:</p>
<ul>
<li><em>ex</em>: East X length</li>
<li><em>cx</em>: Center X length</li>
<li><em>wx</em>: West X length</li>
<li><em>dx</em>: Delta X length (i.e. <em>ex</em> - <em>wx</em>)</li>
<li><em>ny</em>: North Y length</li>
<li><em>cy</em>: Center Y length</li>
<li><em>sy</em>: South Y length</li>
<li><em>dy</em>: Delta Y length (i.e <em>ny</em> - <em>sy</em>)</li>
<li><em>tz</em>: Top Z length</li>
<li><em>cz</em>: Center Z length</li>
<li><em>bz</em>: Bottom Z length</li>
<li><em>dz</em>: Delta Z length (i.e. <em>tz</em> - <em>bz</em>)</li>
<li><em>tne</em>: Top/North/East point (i.e. P(ex, ny, tz))</li>
<li><em>tn</em>: Top/North point (i.e. P(cx, ny, tz))</li>
<li><em>tnw</em>: Top/North/West point (i.e. P(wx, ny, tz))</li>
<li><em>te</em>: Top/East point (i.e. P(ex, cy, cz))</li>
<li><em>t</em>: Top point (i.e. P(cx, cy, tz))</li>
<li><em>tw</em>: Top/West point (i.e. P(wx, cy, tz))</li>
<li><em>tse</em>: Top/South/East point (i.e. P(ex, sy, tz))</li>
<li><em>ts</em>: Top/South/East point (i.e. P(cx, sy, tz))</li>
<li><em>tsw</em>: Top/South/East point (i.e. P(wx, sy, tz))</li>
<li><em>ne</em>: North/East point (i.e. P(ex, ny, cz))</li>
<li><em>n</em>: North point (i.e. P(cx, ny, cz))</li>
<li><em>nw</em>: North/West point (i.e. P(wx, ny, cz))</li>
<li><em>e</em>: East point (i.e. P(ex, cy, cz))</li>
<li><em>c</em>: Center point (i.e. P(cx, cy, cz))</li>
<li><em>w</em>: West point (i.e. P(wx, cy, cz))</li>
<li><em>se</em>: North/East point (i.e. P(ex, sy, cz))</li>
<li><em>s</em>: North/East point (i.e. P(cx, sy, cz))</li>
<li><em>sw</em>: North/East point (i.e. P(wx, sy, cz))</li>
<li><em>bne</em>: Bottom/North/East point (i.e. P(ex, ny, bz))</li>
<li><em>bn</em>: Bottom/North point (i.e. P(cx, ny, bz))</li>
<li><em>bnw</em>: Bottom/North/West point (i.e. P(wx, ny, bz))</li>
<li><em>be</em>: Bottom/East point (i.e. P(ex, cy, bz))</li>
<li><em>b</em>: South point (i.e. P(cx, cy, bz))</li>
<li><em>bw</em>: Bottom/West point (i.e. P(wx, cy, bz))</li>
<li><em>bse</em>: Bottom/South/East point (i.e. P(ex, sy, bz))</li>
<li><em>bs</em>: Bottom/South/East point (i.e. P(cx, sy, bz))</li>
<li><em>bsw</em>: Bottom/South/East point (i.e. P(wx, sy, bz)) </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Nov 16 2013 23:53:12 for EZCAD by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
