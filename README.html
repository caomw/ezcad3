<h1>EZCAD3: Easy (Mechanical) Computer Aided Design -- Version 3</h1>

<h2>Introduction</h2>

<p>EZCAD stands for Easy Computed Aided Design.  EZCAD is a
mechanical CAD (Computer Aided Design) system with an integrated
mechanical CAM (Computer Aided Manufacture) system.  The CAD
system specifies the geometry of individual parts and how they
are assembled together.  The CAM system specifies the
manufacturing steps required to make a part.</p>

<p>In EZCAD, the designer writes a program using the
<a href="http://www.python.org/">Python</a> programming language.
The python program is then executed to generate both the
design visualization and all associated manufacturing files
(e.g. .stl files for 3-printers, G-codes for CNC mills/lathes,
.dxf files for laser printers, etc.)  EZCAD does not include
either a text editor or a visualization tool.  Instead, the designer
uses their preferred text editor (e.g. idle, emacs, vim, etc.) and
they use their own preferred visualization tools  (e.g. meshlab,
etc.)  Other tools are used to visualize generated manufacturing
files.</p>

<p>In short, EZCAD is just a Python library that is executed to generate
the various design files.</p>

<h2>Downloading, Documentation, and Licensing</h2>

<h3>Downloading</h3>

<p>This package is distributed in source form from a <em>git</em> repository.
To get a copy:</p>

<pre><code>    git clone https://github.com/waynegramlich/ezcad3.git
</code></pre>

<p>In addition, this package needs a version of
<a href="http://www.openscad.org/">OpenSCAD</a>.  For those who use
Linux distributions based on the Debian package system
(e.g. Ubuntu, Mint, etc.), the following will do the trick:</p>

<pre><code>    sudo apt-get install openscad
</code></pre>

<p>OpenSCAD is primarily used as a front-end to the wonderful
<a href="http://www.cgal.org/">CGAL</a>(Computational Geometry Algorithms
Library).  In particular, OpenSCAD uses the Boolean 3D solids
library embodied in the NEF3 sub-library of CGAL.</p>

<p>Detailed documentation of the Python classes and associated
methods is maintained by <a href="http://www.doxygen.org/">Doxygen</a>.
For convenience, all of the generated Doxygen documenation
is checked into the repository.  If you want to generated
Doxygen documentation locally, you need to download the program.
I downloaded my copy via:</p>

<pre><code>    sudo apt-get install doxygen
</code></pre>

<h3>Documentation</h3>

<p>In addition to this document, there is
<a href="html/pages.html">Doxygen generated documentation</a>.</p>

<h3>Licensing</h3>

<p>In general, I really like Open Source Licenses.  I have a slight
preference of the GPL open source license, so that is what EZCAD3
is released under.  I emulate the
<a href="http://www.fsf.org">Free Software Foundation</a> that any code
contributed to my code branch requires a copyright assignment.
Professor Eben Moglen has written up a short explanation of
<a href="http://www.gnu.org/licenses/why-assign.html">Why the FSF gets copyright assignments from
contributors</a>.
I strongly feel that having a unified copyright owner provides
maximum protection for the open source software.  While it is
possible to get
<a href="http://ftp.xemacs.org/old-beta/FSF/assign.changes">overly legalistic</a>,
I think the following is more that adequate to assign the copyright:</p>

<pre><code>    Hello:

    I am assigning my modifications to EZCAD to
    Wayne C. Gramlich with the requirement that the code
    will continue to be released under the GPL version 3
    license or higher.

    Regards,

    {Your name here}
</code></pre>

<p>Enough on this legal stuff!</p>

<h2>EZCAD Overview</h2>

<p>In EZCAD, the most important Python class is the <em>Part</em> class.  The
<em>Part</em> class is used to both manufacture individual parts <em>and</em> to
assemble the individual parts together into sub-assemblies.</p>

<p>In addition to the <em>Part</em> class there are bunch of utility classes.
In alphabetical order, the utility classes are:</p>

<ul>
<li><p><em>Angle</em> is used to represent angles.</p></li>
<li><p><em>Color</em> is used to represent a represent the color that an individual
part is rendered as.</p></li>
<li><p><em>L</em> is used to represent a length  (e.g. mm, cm, inch, ft, etc.)
(This type is shortened to "L" because is used so much.)</p></li>
<li><p><em>Material</em> specifies what material a part is manufactured out of.</p></li>
<li><p><em>P</em> is used to represent a point in a 3-dimensional Cartesian
coordinate system.  (This type is shortened to "P" because is used
so much.)</p></li>
<li><p><em>Place</em> is used to represent a <em>Part</em> placement in a sub-assembly.</p></li>
</ul>

<p>Each EZCAD class method validates that its arguments types are correct.
(If you have ever heard of the "duck typing" design pattern, EZCAD
most definitely does <strong>not</strong> use that particular programming religion.)</p>

<p>The CAM (Computer Aided Manufacture) portion is based on the
following classes:</p>

<ul>
<li><p><em>EZCAD</em> is the global object that orchestrates the entire process.</p></li>
<li><p><em>Shop</em> is the parent class that specifies all the available
machines and associated machine tooling.</p></li>
<li><p><em>Machine</em> is a specific machine such as a 3D-printer, laser-cutter,
mill, lathe, drill press, etc.</p></li>
<li><p><em>Tool</em> is a specific tool that can be loaded into a machine.
These include drill bits, end-mills, etc.</p></li>
</ul>

<p>The shop is specified independently from the part and sub-assembly
file.  The same part will generate different manufacturing files
depending upon what machines and tooling is available in a given shop.
Thus, different G-codes, .dxf files are generated depending upon
what is available in the shop.</p>

<p>EZCAD operates in three distinct phases:</p>

<ul>
<li><p>Part Initialization.  This phase creates a hierarchical name space
of parts and sub-assemblies.</p></li>
<li><p>Constraint Propagation.  This phase propagates dimensional changes
around the overall design.  This process also keeps track of the
bounding box around each individual part and sub-assembly.</p></li>
<li><p>Manufacture and Assembly.  This phase generates the required
manufacturing files needed for construct the various parts.
This phase also specifies where <em>Part</em>'s are placed in each
sub-assembly.</p></li>
</ul>

<p>Each phase is quickly discussed below:</p>

<h3>Part Initialization Phase</h3>

<p>Each user individual part is implemented as a Python class object that
sub-classes the <em>Part</em> super class.  As expected, the initialization phase
occurs in the <I><strong>init</strong></I>() method.  Each part has an up-level parent
(abbreviated as "<em>up</em>").  The following code fragment shows how it is
done:</p>

<pre><code>    class My_Part(Part):

        def __init__(self, up):
            Part.__init__(self, up)      # Initialize *Part* super-class
            self.part1_ = Part1(self)    # Initialize *Part1*
            # ...
            self.partN_ = PartN(self)    # Initialize *PartN*
</code></pre>

<p>The first line initializes the <em>Part</em> super class with <em>up</em> as the
up-level parent.  The second and subsequent lines initializes the
various sub-parts.  By convention, each sub-<em>Part</em> is stored into
<em>self</em> with a trailing "_" suffix.  (There will be more about suffixes
shortly.)</p>

<p>After initialization is complete, each <em>Part</em> can access any other
<em>Part</em> in the design using standard dot (".") notation.  For example,
<em>self.up.base_</em> will access the <em>base_</em> <em>Part</em> of the parent to <em>self</em>.</p>

<p>Due to the nature of Python, the designer will be storing dimensional
values into <em>Part</em> member variables.  EZCAD uses member variable suffixes
to prevent accidental name clashes.  Designers are constrained to use
a suffixes listed below:</p>

<ul>
<li>"_": <em>Part</em></li>
<li>"_a": <em>Angle</em></li>
<li>"_c": <em>Color</em>p</li>
<li>"_i": <em>int</em> (i.e. an integer number)</li>
<li>"_f": <em>float</em> (i.e. a floating point number)</li>
<li>"_l": <em>L</em> (i.e. a length)</li>
<li>"_m": <em>Material</em></li>
<li>"_o": Some other type</li>
<li>"_s": <em>str</em> (i.e. string)</li>
<li>"_p": <em>P</em> (i.e. a point)</li>
<li>"_pl": <em>Place</em></li>
</ul>

<p>All user defined member variables <em>must</em> end with one of the suffixes above.</p>

<h3>Constraint Propagation Phase</h3>

<p>Constraint propagation is what allows the designer to relatively easily
resize a design.  The constraint propagation phase occurs in a
<em>Part</em>'s <em>construct</em>() method.  Constraint propagation occurs by
repeatably calling the <em>construct</em>() method for each <em>Part</em> in
the entire design.  The <em>construct</em>() methods are repeatably called
until none of the values with approved suffixes (e.g. "_l", "_p")
change any more.</p>

<p>To further support constraint propagation, each <em>Part</em> maintains a
bounding box for everything it contains.  The bounding box uses
an altitude/compass bearing naming convention.  Using this convention,
the X axis is uses East/Center/West names, the Y axis uses
North/Center/South names, and the Z axis uses Top/Center/Bottom name.
The following crude ASCII art should help to convey the concept.</p>

<pre><code>                T  N (Y axis)
                | /
                |/
          W-----*-----E (X axis)
               /|
              / |
             S  B
               (Z-axis)
</code></pre>

<p>The bounding box of a part defines box that consists of 3 by 3 x 3
points.  There are three slices -- the top slice, the center slice,
and bottom slice that are named as follows:</p>

<pre><code>      tnw--tn---tne     nw----n----ne     bnw--bn---bne
      |     |     |     |     |     |     |     |     |
      tw----t----tw     w-----c-----e     bw----b----bw
      |     |     |     |     |     |     |     |     |
      tsw--ts---tse     sw----s----se     bsw--bs---bse
       (Top Slice)      (Center Slice)    (Bottom Slice)
</code></pre>

<p>The designer can easily access the various bounding box values
using short concise member variable names.  Thus, the <em>tne</em>
member variable corresponds to the Top-North-West corner of
the bounding box, <em>c</em> corresponds to the Center of the bounding
box, and <em>bw</em> corresponds to the Bottom-West edge of the
bounding box.</p>

<p>Using constraint propagation and bounding boxes, EZCAD encourages
the use of the  <em>assembly focused</em> design pattern where each
part is designed to fit precisely into the final assembly from the
beginning.  This is in contrast to the <em>part focused</em> design
pattern where each part is individually designed and then
subsequently fitted into the final assembly.</p>

<h3>Manufacture and Assembly Phase</h3>

<p>The manufacturing and assembly phase occurs last.  EZCAD can generate
manufacturing files for the following generic classes of machines:</p>

<ul>
<li><p>3D Printers (.stl file)</p></li>
<li><p>Laser Cutters (.dxf file)</p></li>
<li><p>CNC Mills and Lathes (CNC file)</p></li>
</ul>

<p>EZCAD uses a design for manufacture strategy.  For each part, the
designer specifies one or more appropriate machines that could be
used to manufacture the part.  While some parts can only be manufactured
on a single machine class, others can be manufactured on more than
one machine class.  For example, a plastic plate that has some holes,
inter cut outs, and a specific exterior contour can actually be
manufactured on a CNC mill, laser cutter, or 3D printer.  The
decision of which machine to use is deferred until the actual part
needs to be manufactured.</p>

<p>EZCAD uses a two step process for designing a part:</p>

<ul>
<li><p>First, a bunch of material chunks (e.g. blocks, cylinders,
extrusions, etc.) are "welded" together to provide a rough
3D chunk of material.</p></li>
<li><p>Second, a bunch of material removal operations (e.g. holes,
pockets, exterior contour removal, etc.)</p></li>
</ul>

<p>The details of these operations are deferred until later.</p>

<p>After each part is designed, there is a final step of placing
each part into the final assembly.  A single part or sub-assembly
can easily be replicated multiple times in the final assembly.</p>

<p>Once the final assembly is present, it can be viewed using the
appropriate </p>

<h3>A Quick Example</h3>

<p>The example below creates a plastic box with a cover, where the
cover has a lip that keeps the cover centered over the box.
We present the entire code body first then will describe
what is happening on a chunk by chunk basis next:</p>

<pre><code>    #!/usr/bin/env python

    from EZCAD3 import *   # The EZCAD (revision 3) classes:

    class Simple_Box(Part):

        def __init__(self, up, dx=L(mm=100.0), dy=L(mm=50.0),
          dz=L(25.0), wall_thickness=L(mm=5.0),
          material=Material("plastic", "ABS")):
            # Initialize the *Part*:
            Part.__init__(self, up)

            # Remember the initialization values:
            self.dx_l = dx
            self.dy_l = dy
            self.dz_l = dz
            self.wall_thickness_l = wall_thickness
            self.material_m = material

            # Instantiate the sub-*Part*'s:
            self.base_ = Simple_Box_Base(self)
            self.cover_ = Simple_Box_Cover(self)

        def construct(self):
            pass

    class Simple_Box_Base(Part):

        def __init__(self, up, place = True):
            Part.__init__(self, up, place)

        def construct(self):
            # Grab some values from *box*:
            box = self.up
            dx = box.dx_l
            dy = box.dy_l
            dz = box.dz_l
            wall_thickness = box.wall_thickness_l
            material = box.material_m

            # Add another 
            self.height_l = height = dz - wall_thickness
            zero = L()

            # Start with a solid block of the right dimensions:
            height = dz - wall_thickness
            self.block(comment = "Initial block of material",
              material = material,
              color = Color("blue", alpha=.5),
              corner1 = P(-dx/2, -dy/2, zero),
              corner2 = P( dx/2,  dy/2, height))

            # Pocket out the body of the box:
            self.simple_pocket(comment = "Box Pocket",
             corner1 = self.bsw + P(wall_thickness,
               wall_thickness, wall_thickness),
             corner2 = self.tne - P(wall_thickness,
               wall_thickness, L(mm=-.1)))

    class Simple_Box_Cover(Part):

        def __init__(self, up, place = True):
            Part.__init__(self, up, place)

        def construct(self):
            # Grab some values from *parent* and *base*:
            box = self.up
            dx = box.dx_l
            dy = box.dy_l
            dz = box.dz_l
            material = box.material_m
            wall_thickness = box.wall_thickness_l
            base = box.base_
            base_height = base.height_l
            zero = L()

            # Compute local values:
            self.lip_thickness = lip_thickness = wall_thickness/2

            # Do the top part of the cover:
            self.block(comment = "Cover Top",
              material = material,
              color = Color("green", alpha=0.5),
              corner1 = base.tsw,
              corner2 = base.tne + P(z = wall_thickness))

            # Do the lip part of the cover:
            self.block(comment = "Cover Lip",
              corner1 = base.tsw + P(wall_thickness,
                wall_thickness, -lip_thickness),
              corner2 = base.tne + P(-wall_thickness,
                -wall_thickness, zero))

    ezcad = EZCAD3(0)                # Using EZCAD 3.0
    simple_box = Simple_Box(None)   # Initialize top-level sub-assembly
    simple_box.process(ezcad)       # Process the design
</code></pre>

<p>The final step is:</p>

<pre><code>    ezcad = EZCAD3(0)                # Using EZCAD 3.0
    my_assembly = My_Assembly(None)  # Initialize top-level sub-assembly
    my_assembly.process(ezcad)       # Process the design
</code></pre>

<p>In this code sequence, an <em>EZCAD3</em> object is allocated and initialized.
The major revision number is 3 and the minor revision number is 0.
Next, the top-level sub-assembly is allocated and initialized.
Finally, the <em>process</em>() method is invoked to cause the design
to be processed.  For those of you who like to scrunch everything
onto one line:</p>

<pre><code>    Simple_Box(None).process(EZCAD3(0))
</code></pre>

<p>will also do the trick.</p>

<h2>CAD Class Reference</h2>

<p>This section coveres the design classes.  The lower level
classes are covered first, followed by the <em>Part</em> class.
The next major section after this covers the manufacturing
classes (e.g. <em>Shop</em>, <em>Machine</em>, <em>Tool</em>, etc.</p>

<h3>The <em>Angle</em> Class</h3>

<p>The <em>Angle</em> class represents an angle.  While most designers
specify their angles in degrees, internally the <em>Angle</em> class
represents angles in radians.</p>

<p>The initializer can specify angles in either degrees or radians:</p>

<pre><code>    degrees0 = Angle()                    # No arguments is 0 degrees
    degrees90 = Angle(deg = 90.0)         # Angle specified in degrees
    degrees180 = Angle(rad = 3.14.15926)  # Angle specified in radians
</code></pre>

<p>An <em>Angle</em> can be convert back into a <em>float</em> using a conversion method:</p>

<pre><code>    d = degrees90.deg()                   # Convert to degrees
    r = degress180.rad()                  # Convert to radians
</code></pre>

<p><em>Angle</em>'s can be added, subtracted, multiplied, divided, etc.:</p>

<pre><code>    a = degrees90 + degrees180            # Addition
    b = degrees90 - degrees180            # Subtraction
    c = degrees90 * 3                     # Multiplication
    d = degrees90 / 3                     # Division
    e = -degrees90                        # Negation
</code></pre>

<p>Comparison of <em>Angle</em> objects is supported:</p>

<pre><code>    eq = degrees90 == degrees90     # Equality
    ge = degrees180 &gt;= degrees90    # Greater than or equal
    gt = degrees180 &gt; degrees90     # Greater than
    le = degress0 &lt;= degress180     # Less than or equal
    lt = degress0 &lt; degress180      # Less than
    ne = degrees0 != degress180     # Inequality
</code></pre>

<p>An <em>Angle</em> object can be formatted using the standard Python format
facility.  The units can be specified by suffix character:</p>

<pre><code>    angle = Angle(deg = 180.0)
    print("degrees={0:d} radians={0:r}".format(angle))
</code></pre>

<p>will print:</p>

<pre><code>    degrees=180.0 radians=3.14159265359
</code></pre>

<p>There are three trigimetric functions for angles:</p>

<pre><code>    angle.sine()                    # sin(angle)
    angle.cosine()                  # cos(angle)
    angle.tangent()                 # tan(angle)
</code></pre>

<p>There is a miscellaneous <em>Angle</em> class:</p>

<pre><code>    angle.normalize()               # Angle between -180 and  180 degrees
</code></pre>

<p>Read the
<a href="html/classEZCAD3_1_1Angle.html">Doxygen generated <em>Angle</em> class information</a>
to get the detailed method documenation.</p>

<h3>The <em>Color</em> Class</h3>

<p><em>Color</em> class documentation goes here.</p>

<h3>The <em>L</em> (i.e. Length) Class</h3>

<p>The <em>L</em> class represents a length.  While the length can be specified
in units of centimeters, millimeters, inches, and feet, internally,
the <em>L</em> class converts everything to millimeters.  Here are some
examples of creating a length:</p>

<pre><code>    length0 = L()                   # Length of 0.0
    length2mm = L(mm = 2)           # 2.0 millimeters (note *int* is OK)
    length3_5cm = L(cm = 3.5)       # 3.5 centimeters
    length1thou = L(inch = .001)    # One thousandth of an inch
    length6feet = L(ft = 3)         # 3 feet (which happens to be 1 yard)
    length1_3_4 = L(inch = "1-3/4") # 1.75 inches
</code></pre>

<p>An <em>L</em> object can be converted back into <em>float</em> using a conversion method:</p>

<pre><code>    length.mm()                     # Millimeters
    length.cm()                     # Centimeters
    length.inch()                   # Inches
    length.ft()                     # Feet.
</code></pre>

<p>As expected, <em>L</em> objects can be added, subtracted, multiplied, divided, etc.:</p>

<pre><code>    a = length2mm + length1though   # Addition
    b = length6feet - length3_5cm   # Subtraction
    c = length6feet * 2             # Mulitplication by *int* (or *float*)
    d = length2mm / 2.3             # Division by a *float* (or *int*)
    e = -length3_5cm                # Negation
</code></pre>

<p>Comparisons between <em>L</em> object are permitted:</p>

<pre><code>    eq = length2mm == length2mm     # Equality
    ge = length2mm &gt;= length0       # Greater than or equal
    gt = length2mm &gt; length1thou    # Greater than
    le = length0 &lt;= length2mm &lt;=    # Less than or equal
    lt = length1thou &lt; length2mm &lt;  # Less than
    ne = length3_5cm != length6feet # Inequality
</code></pre>

<p><em>L</em> object can be formatted using the Python formatting system.
For example:</p>

<pre><code>    length = L(inch = 1)
    print("mm={0:m} cm={0:c} inch={0:i} ft={0:f}".format(length))
</code></pre>

<p>will print out:</p>

<pre><code>    mm=25.4 cm=2.54 inch=1.0 ft=0.08333333333
</code></pre>

<p>If no suffix is provided, millimetes will be used the for output units.
In general, it is best to always specify the units.</p>

<p>In addition, it is possible to use standard float syntax to futher
control the formatting.  Thus:</p>

<pre><code>    print("ft={0:.4f}".format(length)
</code></pre>

<p>will print out:</p>

<pre><code>ft=0.8333
</code></pre>

<p>There are trigametric methods for <em>L</em> objects that multiply
the a length by a trigimetric function:</p>

<pre><code>    length.sine(angle)        # == length * angle.sine()
    length.cosine(angle)      # == length * angle.cosine()
    length.tangent(angle)     # == length * angle.tangent()
</code></pre>

<p>In addtion there is:</p>

<pre><code>    dy.arctangent2(dx)        # == Angle(rad=math.atan2(dy.mm(), dz.mm()))
</code></pre>

<p>There are a few miscellaneous <em>L</em> methods as well:</p>

<pre><code>    length1.absolute()        # Absolute value of (length1)
    length1.maximim(length2)  # Maximum of length1 and length2
    length2.minimum(length2)  # Minimum of length1 and length2
</code></pre>

<p>The detailed method documentation generated by Doxygen is
<a href="html/classEZCAD3_1_1L.html">available</a>.</p>

<h3>The <em>Material</em> Class</h3>

<p><em>Matierial</em> class documentation goes here.</p>

<h3>The <em>P</em> (i.e. point) class</h3>

<p><em>P</em> class documenation goes here.</p>

<h3>The <em>Part</em> Class</h3>

<p><em>Part</em> Class documenation goes here:</p>

<p>Bounding Box:</p>

<ul>
<li><em>ex</em>:  East   X length</li>
<li><em>cx</em>:  Center X length</li>
<li><em>wx</em>:  West   X length</li>
<li><em>dx</em>:  Delta  X length (i.e. <em>ex</em> - <em>wx</em>)</li>
<li><em>ny</em>:  North  Y length</li>
<li><em>cy</em>:  Center Y length</li>
<li><em>sy</em>:  South  Y length</li>
<li><em>dy</em>:  Delta  Y length (i.e <em>ny</em> - <em>sy</em>)</li>
<li><em>tz</em>:  Top    Z length</li>
<li><em>cz</em>:  Center Z length</li>
<li><em>bz</em>:  Bottom Z length</li>
<li><em>dz</em>:  Delta  Z length (i.e. <em>tz</em> - <em>bz</em>)</li>
<li><em>tne</em>: Top/North/East    point (i.e. P(ex, ny, tz))</li>
<li><em>tn</em>:  Top/North         point (i.e. P(cx, ny, tz))</li>
<li><em>tnw</em>: Top/North/West    point (i.e. P(wx, ny, tz))</li>
<li><em>te</em>:  Top/East          point (i.e. P(ex, cy, cz))</li>
<li><em>t</em>:   Top               point (i.e. P(cx, cy, tz))</li>
<li><em>tw</em>:  Top/West          point (i.e. P(wx, cy, tz))</li>
<li><em>tse</em>: Top/South/East    point (i.e. P(ex, sy, tz))</li>
<li><em>ts</em>:  Top/South/East    point (i.e. P(cx, sy, tz))</li>
<li><em>tsw</em>: Top/South/East    point (i.e. P(wx, sy, tz))</li>
<li><em>ne</em>:  North/East        point (i.e. P(ex, ny, cz))</li>
<li><em>n</em>:   North             point (i.e. P(cx, ny, cz))</li>
<li><em>nw</em>:  North/West        point (i.e. P(wx, ny, cz))</li>
<li><em>e</em>:   East              point (i.e. P(ex, cy, cz))</li>
<li><em>c</em>:   Center            point (i.e. P(cx, cy, cz))</li>
<li><em>w</em>:   West              point (i.e. P(wx, cy, cz))</li>
<li><em>se</em>:  North/East        point (i.e. P(ex, sy, cz))</li>
<li><em>s</em>:   North/East        point (i.e. P(cx, sy, cz))</li>
<li><em>sw</em>:  North/East        point (i.e. P(wx, sy, cz))</li>
<li><em>bne</em>: Bottom/North/East point (i.e. P(ex, ny, bz))</li>
<li><em>bn</em>:  Bottom/North      point (i.e. P(cx, ny, bz))</li>
<li><em>bnw</em>: Bottom/North/West point (i.e. P(wx, ny, bz))</li>
<li><em>be</em>:  Bottom/East       point (i.e. P(ex, cy, bz))</li>
<li><em>b</em>:   South             point (i.e. P(cx, cy, bz))</li>
<li><em>bw</em>:  Bottom/West       point (i.e. P(wx, cy, bz))</li>
<li><em>bse</em>: Bottom/South/East point (i.e. P(ex, sy, bz))</li>
<li><em>bs</em>:  Bottom/South/East point (i.e. P(cx, sy, bz))</li>
<li><em>bsw</em>: Bottom/South/East point (i.e. P(wx, sy, bz))</li>
</ul>
